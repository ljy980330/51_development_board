/*********************************************************************************************************
*名称：sende.c
*功能：spi――无线模块的定义及发送函数
创建时间：2019/7/8
修改时间：2019/7/11
作者：黄彦钊
*********************************************************************************************************/
#include"send.h"
//1//sbit KEY1=P0^0;	 		//发送按键 
//1//sbit KEY2=P0^1;
//1//sbit KEY3=P0^2;
//1//sbit KEY4=P0^3;
sbit beep=P2^3;					//喇叭 
sbit LED6=P1^6;	 				//发送数据时显示灯+接收到数据后的功能实现灯

uchar Tx_Buf1[]={1};			//发送的信息1 
uchar Rx_Buf[32];  				//接收到的数据暂存器，最多32字节数据  			  
				 
uchar uart_flag,a;			//串口接收标志【收到数据就置1】,a为接收到的数据

/*******************************************************************************
* 函 数 名         : run
* 函数功能		   : 主函数运行
*******************************************************************************/ 
void run()
{
	 LED6=1;				//初始灯6熄灭   
	 uart_flag=0;			//串口标志初始为0
	 init_NRF24L01();		//初始化24L01
	 UART_Init();	    	//初始化串口

	 while(NRF24L01_Check())					//检查不到24l01则报警 
	 {
		beep=0;
		delay_ms(200);
		beep=1;
		delay_ms(200);
	 }
	 while(1)
	 {	
		RX_Mode();							//接收模式  
		while(!nRF24L01_RxPacket(Rx_Buf)) 	//等待接收数据,返回1则接收到数据,在等待接收数据期间,可以随时变成发送模式  
	    {
			if(uart_flag==1)				//当串口接受标志为1表示有数据过来
			{
				ES=0;	   						//关串口中断
			
				TX_Mode();	 					//发送模式 
				Tx_Buf1[0]=a-'0';					//将串口数据给发送缓冲区
			    nRF24L01_TxPacket(Tx_Buf1);		//发送命令数据24L01
				UART_Send_Byte('O');			//向串口发送已经传送
				UART_Send_Byte('K');
				UART_Send_Byte(':');
				UART_Send_Byte(a);
				UART_Send_Byte('\n');
				LED6=0;
			    delay_ms(300);
				LED6=1;
			    delay_ms(300);					//发送后LED1闪一下 

				ES=1;							//允许串口中断
				uart_flag=0;  					//中断标志位置0
				break;							//退出最近的循环,从而变回接收模式,这句关键
			}
		 }
		 if(Rx_Buf[0]==1)	   						//若接收到对应的数据则实现对应功能 
		 {
		     Rx_Buf[0]=0;				//清空数据 
		     LED6=0;
		 	 delay_ms(300);
		 	 LED6=1;
		 	 delay_ms(300);				//接收到数据 后闪烁	  
		 }
	 }
}
	   					  
/*------------------------------------------------
串口接收中断服务程序
------------------------------------------------*/
void UART() interrupt 4
{
	if(RI)	   			//检测接收完成标志位置1
	{
		RI=0;			//清零接收完成标志位
		a=SBUF;			//读取接收到的数据
		uart_flag = 1;	//中断标志位置1
	}
}