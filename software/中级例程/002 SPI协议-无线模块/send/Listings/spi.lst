C51 COMPILER V9.00   SPI                                                                   07/25/2019 20:47:52 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SPI
OBJECT MODULE PLACED IN .\Objects\spi.obj
COMPILER INVOKED BY: F:\workApp\Keil_v5\C51\BIN\C51.EXE spi\spi.c BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\spi.lst) OB
                    -JECT(.\Objects\spi.obj)

line level    source

   1          /*********************************************************************************************************
   2          *名称：spi.c
   3          *功能：spi驱动定义及函数
   4          创建时间：2019/7/8
   5          修改时间：2019/7/11
   6          作者：黄彦钊
   7          *********************************************************************************************************/
             -        
   8          #include <STC12C5A.H>
   9          #include "spi/spi.h"  
  10          #include "delay/delay.h"
  11          
  12          sbit    CE          =P1^0;
  13          sbit    CSN             =P1^1;
  14          sbit    SCK         =P1^2;
  15          sbit    MOSI    =P1^3;
  16          sbit    MISO    =P1^4;
  17          sbit    IRQ             =P1^5;
  18          
  19          #define TX_ADR_WIDTH    5       // 5 单位的Tx地址宽度
  20          #define RX_ADR_WIDTH    5       // 5 单位的Rx地址宽度
  21          #define TX_PLOAD_WIDTH  32      // 32 单位的Tx地址宽度
  22          #define RX_PLOAD_WIDTH  32      // 32 单位的Rx地址宽度
  23          uchar  TX_ADDRESS[TX_ADR_WIDTH]= {0xE7,0xE7,0xE7,0xE7,0xE7};    //本地地址
  24          uchar  RX_ADDRESS[RX_ADR_WIDTH]= {0xE7,0xE7,0xE7,0xE7,0xE7};    //接收地址
  25          
  26          ///***************************************NRF24L01寄存器指令**********************************************
             -*********
  27          #define READ_REG        0x00    // 读寄存器指令
  28          #define WRITE_REG       0x20    // 写寄存器指令
  29          #define RD_RX_PLOAD     0x61    // 读取接收数据指令
  30          #define WR_TX_PLOAD     0xA0    // 写待发数据指令
  31          #define FLUSH_TX        0xE1    // 冲洗发送 FIFO指令
  32          #define FLUSH_RX        0xE2    // 冲洗接收 FIFO指令
  33          #define REUSE_TX_PL     0xE3    // 定义重复装载数据指令
  34          #define NOP             0xFF    // 保留
  35          
  36          ///*************************************SPI(nRF24L01)寄存器地址*******************************************
             -*********
  37          #define CONFIG          0x00  // 配置收发状态，CRC校验模式以及收发状态响应方式
  38          #define EN_AA           0x01  // 自动应答功能设置
  39          #define EN_RXADDR       0x02  // 可用信道设置
  40          #define SETUP_AW        0x03  // 收发地址宽度设置
  41          #define SETUP_RETR      0x04  // 自动重发功能设置
  42          #define RF_CH           0x05  // 工作频率设置
  43          #define RF_SETUP        0x06  // 发射速率、功耗功能设置
  44          #define NRFRegSTATUS    0x07  // 状态寄存器
  45          #define OBSERVE_TX      0x08  // 发送监测功能
  46          #define CD              0x09  // 地址检测           
  47          #define RX_ADDR_P0      0x0A  // 频道0接收数据地址
  48          #define RX_ADDR_P1      0x0B  // 频道1接收数据地址
  49          #define RX_ADDR_P2      0x0C  // 频道2接收数据地址
  50          #define RX_ADDR_P3      0x0D  // 频道3接收数据地址
  51          #define RX_ADDR_P4      0x0E  // 频道4接收数据地址
C51 COMPILER V9.00   SPI                                                                   07/25/2019 20:47:52 PAGE 2   

  52          #define RX_ADDR_P5      0x0F  // 频道5接收数据地址
  53          #define TX_ADDR         0x10  // 发送地址寄存器
  54          #define RX_PW_P0        0x11  // 接收频道0接收数据长度
  55          #define RX_PW_P1        0x12  // 接收频道1接收数据长度
  56          #define RX_PW_P2        0x13  // 接收频道2接收数据长度
  57          #define RX_PW_P3        0x14  // 接收频道3接收数据长度
  58          #define RX_PW_P4        0x15  // 接收频道4接收数据长度
  59          #define RX_PW_P5        0x16  // 接收频道5接收数据长度
  60          #define FIFO_STATUS     0x17  // FIFO栈入栈出状态寄存器设置
  61          
  62          ///*****************************子函数集*********************************************************
  63          uchar NRF24SPI_Send_Byte(uchar dat);
  64          uchar SPI_WR_Reg(uchar reg, uchar value);
  65          uchar SPI_Read_Buf(uchar reg, uchar *pBuf, uchar Len);
  66          uchar SPI_Write_Buf(uchar reg, uchar *pBuf, uchar Len);
  67          uchar nRF24L01_RxPacket(unsigned char* rx_buf);
  68          void nRF24L01_TxPacket(unsigned char * tx_buf);
  69          uchar SPI_RD_Reg(uchar reg);
  70          void init_NRF24L01(void);
  71          void TX_Mode(void);
  72          void RX_Mode(void);
  73          void NRF_Send(void);
  74          uchar NRF24L01_Check(void);
  75          /*******************************************************************************
  76          * 函 数 名         : NRF24SPI_Send_Byte
  77          * 函数功能                 : 发送一字节[MOSI和MISO数据传递]
  78          *******************************************************************************/
  79          uchar NRF24SPI_Send_Byte(uchar dat)
  80          {
  81   1              uchar i;
  82   1              for (i = 0; i < 8; i++) //output 8-bit
  83   1              {
  84   2                      //写入1位数据
  85   2                      MOSI=(dat & 0x80);      //output 'uchar', MSB to MOSI
  86   2                      dat<<= 1;           // shift next bit into MSB..
  87   2                      
  88   2                      //读取1位数据
  89   2                      SCK = 1;                        // Set SCK high..
  90   2                      if (MISO){
  91   3                              dat|= 1;
  92   3                      }else{                                  // capture current MISO bit
  93   3                              dat &= 0xFE;
  94   3                      }
  95   2                      SCK = 0;                    // ..then set SCK low again
  96   2              }
  97   1              return(dat);                    // return read uchar
  98   1      }
  99          /*******************************************************************************
 100          * 函 数 名         : run
 101          * 函数功能                 : 主函数运行
 102          *******************************************************************************/ 
 103          uchar NRF24L01_Check(void)
 104          {
 105   1              uchar bu[5]={0XA5,0XA5,0XA5,0XA5,0XA5};
 106   1              uchar bu1[5];
 107   1              uchar i;         
 108   1              SPI_Write_Buf(WRITE_REG+TX_ADDR,bu,5);    //写入5个字节的地址.  
 109   1              SPI_Read_Buf(TX_ADDR,bu1,5);              //读出写入的地址      
 110   1              for(i=0;i<5;i++)if(bu1[i]!=0XA5)break;                                     
 111   1              if(i!=5)return 1;                               //NRF24L01不在位        
 112   1              return 0;                                               //NRF24L01在位
 113   1      }       
C51 COMPILER V9.00   SPI                                                                   07/25/2019 20:47:52 PAGE 3   

 114          /*******************************************************************************
 115          * 函 数 名         : init_NRF24L01
 116          * 函数功能                 : NRF24L01初始化
 117          *******************************************************************************/         
 118          void init_NRF24L01(void)
 119          {
 120   1              uchar buf[5]={0};
 121   1              nop(100);
 122   1              CE = 0;                 // chip enable
 123   1              CSN= 0;                 // Spi disable 
 124   1              
 125   1              SPI_Read_Buf(TX_ADDR, buf, TX_ADR_WIDTH);//debug 测试原来的本地地址：复位值是：0xE7 0xE7 0xE7 0xE7 0xE7
 126   1        
 127   1      //      SPI_Write_Buf(WRITE_REG + TX_ADDR, TX_ADDRESS, TX_ADR_WIDTH);    // 写本地地址  
 128   1      //      SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, RX_ADDRESS, RX_ADR_WIDTH); // 写接收端地址
 129   1      
 130   1      //      
 131   1      //      SPI_WR_Reg(WRITE_REG + EN_AA, 0x01);      //  频道0自动 ACK应答允许     
 132   1      //      SPI_WR_Reg(WRITE_REG + EN_RXADDR, 0x01);  //  允许接收地址只有频道0，如果需要多频道可以参考Page21  
 133   1      //      SPI_WR_Reg(WRITE_REG + SETUP_RETR, 0x1a); // 设置自动重发时间和次数：500us + 86us, 10 retrans...
 134   1      //      SPI_WR_Reg(WRITE_REG + RF_CH, 22);        //   设置信道工作为2.4GHZ，收发必须一致
 135   1      //      SPI_WR_Reg(WRITE_REG + RX_PW_P0, RX_PLOAD_WIDTH); //设置接收数据长度，本次设置为32字节
 136   1      //      SPI_WR_Reg(WRITE_REG + RF_SETUP, 0x07);                 //设置发射速率为1MHZ，发射功率为最大值0dB
 137   1      //  
 138   1      //  SPI_RD_Reg(WRITE_REG + EN_AA);
 139   1      //  SPI_RD_Reg(WRITE_REG + EN_RXADDR);
 140   1      //  SPI_RD_Reg(WRITE_REG + RF_CH);
 141   1      //  SPI_RD_Reg(WRITE_REG + RX_PW_P0);
 142   1      //  SPI_RD_Reg(WRITE_REG + RF_SETUP);
 143   1      }
 144          /*******************************************************************************
 145          * 函 数 名         : uchar SPI_Read
 146          * 函数功能                 : NRF24L01的SPI时序,读取指定寄存器的内容
 147          *******************************************************************************/
 148          uchar SPI_RD_Reg(uchar reg)
 149          {
 150   1              uchar reg_val;
 151   1              CSN = 0;                                        // CSN low, initialize SPI communication...
 152   1              NRF24SPI_Send_Byte(reg);            // Select register to read from..
 153   1              reg_val = NRF24SPI_Send_Byte(0);    // ..then read registervalue
 154   1              CSN = 1;                                        // CSN high, terminate SPI communication        
 155   1              return(reg_val);                                // return register value
 156   1      }
 157          /*******************************************************************************
 158          * 函 数 名         : uchar SPI_Write
 159          * 函数功能                 : NRF24L01的SPI时序,写入指定寄存器的内容
 160          *******************************************************************************/
 161          uchar SPI_WR_Reg(uchar reg, uchar value)
 162          {
 163   1              uchar status;
 164   1              CSN = 0;                                        // CSN low, init SPI transaction
 165   1              status = NRF24SPI_Send_Byte(reg);       // select register
 166   1              NRF24SPI_Send_Byte(value);          // ..and write value to it..
 167   1              CSN = 1;                                        // CSN high again
 168   1              return(status);                                 // return nRF24L01 status uchar
 169   1      }        
 170          /*******************************************************************************
 171          * 函 数 名         : uint SPI_Read_Buf
 172          * 函数功能                 : 用于读数据
 173                                                   reg：为寄存器地址
 174                                                   pBuf：为待读出数据地址
 175                                                   uchars：读出数据的个数
C51 COMPILER V9.00   SPI                                                                   07/25/2019 20:47:52 PAGE 4   

 176          *******************************************************************************/
 177          uchar SPI_Read_Buf(uchar reg, uchar *pBuf, uchar Len)
 178          {
 179   1              uint status,i;
 180   1              CSN = 0;                                // Set CSN low, init SPI tranaction
 181   1              status = NRF24SPI_Send_Byte(reg);   // Select register to write to and read status uchar
 182   1              for(i=0;i<Len;i++){
 183   2                      pBuf[i] = NRF24SPI_Send_Byte(0);
 184   2              }
 185   1              CSN = 1;                          
 186   1              return(status);                         // return nRF24L01 status uchar
 187   1      }
 188          /*******************************************************************************
 189          * 函 数 名         : uint SPI_Write_Buf(uchar reg, uchar *pBuf, uchar Len
 190          * 函数功能                 : 用于写数据
 191                                               reg:为寄存器地址
 192          //                                       pBuf：为待写入数据地址
 193          //                                       uchars：写入数据的个数
 194          *******************************************************************************/
 195          uchar SPI_Write_Buf(uchar reg, uchar *pBuf, uchar Len)
 196          {
 197   1              uint status,i;
 198   1              CSN = 0;                                        //SPI使能       
 199   1              status = NRF24SPI_Send_Byte(reg);   
 200   1              for(i=0; i<Len; i++){
 201   2                 NRF24SPI_Send_Byte(*pBuf);
 202   2                       pBuf ++;
 203   2              }
 204   1              CSN = 1;                                                //关闭SPI
 205   1              return(status);   
 206   1      }
 207          /*******************************************************************************
 208          * 函 数 名         : void SetRX_Mode
 209          * 函数功能                 : 数据接收配置 
 210          *******************************************************************************/
 211          void RX_Mode(void)
 212          {
 213   1          uchar buf[5]={0};
 214   1              CE = 0;
 215   1              SPI_Read_Buf(TX_ADDR,buf, TX_ADR_WIDTH);        //debug 测试原来的本地地址：复位值是：0xE7 0xE7 0xE7 0xE7 0xE7
 216   1              //SPI_WR_Reg(WRITE_REG + CONFIG, 0x03);//SPI_WR_Reg(WRITE_REG + CONFIG, 0x0f); // IRQ收发完成中断响应，16
             -位CRC        ，主接收
 217   1              //SPI_Write_Buf(WRITE_REG + TX_ADDR, TX_ADDRESS, TX_ADR_WIDTH);         // 写本地地址   
 218   1              SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, RX_ADDRESS, RX_ADR_WIDTH);        // 写接收端地址
 219   1              SPI_WR_Reg(WRITE_REG + EN_AA, 0);                               //频道0自动     ACK应答允许     
 220   1              SPI_WR_Reg(WRITE_REG + EN_RXADDR,0x01);                         //允许接收地址只有频道0，如果需要多频道可以参考Page21  
 221   1              SPI_WR_Reg(WRITE_REG + SETUP_RETR,0x1a);                        //设置自动重发时间和次数：500us + 86us, 10 retrans...
 222   1              SPI_WR_Reg(WRITE_REG + RF_CH, 40);                              //设置信道工作为2.4GHZ，收发必须一致
 223   1              SPI_WR_Reg(WRITE_REG + RX_PW_P0, RX_PLOAD_WIDTH);       //设置接收数据长度，本次设置为32字节
 224   1              SPI_WR_Reg(WRITE_REG + RF_SETUP, 0x0F);                         //设置发射速率为2MHZ，发射功率为最大值0dB
 225   1              SPI_WR_Reg(WRITE_REG + CONFIG, 0x0F);
 226   1              CE = 1; 
 227   1              nop(200); //200us
 228   1      } 
 229          /*******************************************************************************
 230          * 函 数 名         : unsigned char nRF24L01_RxPacke
 231          * 函数功能                 : 数据读取后放入rx_buf接收缓冲区中
 232          *******************************************************************************/
 233          uchar nRF24L01_RxPacket(unsigned char* rx_buf)
 234          {
 235   1          uchar flag=0;
 236   1          uchar status;
C51 COMPILER V9.00   SPI                                                                   07/25/2019 20:47:52 PAGE 5   

 237   1              
 238   1              status=SPI_RD_Reg(NRFRegSTATUS);        //读取状态寄存其来判断数据接收状况
 239   1              
 240   1              if(status & 0x40)                                       //判断是否接收到数据
 241   1              {
 242   2                       CE=0;                  //SPI使能
 243   2                       SPI_Read_Buf(RD_RX_PLOAD,rx_buf,TX_PLOAD_WIDTH);       // read receive payload from RX_FIFO buffer
 244   2                       flag =1;                                                                                       //读取数据完成标志
 245   2              }
 246   1              SPI_WR_Reg(WRITE_REG+NRFRegSTATUS, status);                     //接收到数据后RX_DR,TX_DS,MAX_RT都置高为1，通过写1来清楚
             -中断标志
 247   1              return flag;
 248   1      }        
 249          /*******************************************************************************
 250          * 函 数 名         : void TX_Mode(void)
 251          * 函数功能                 : 数据接收配置
 252          *******************************************************************************/
 253          void TX_Mode(void)
 254          {
 255   1          CE = 0;
 256   1              //SPI_WR_Reg(WRITE_REG + CONFIG, 0x02);   //0x0E                 // IRQ收发完成中断响应，16位CRC，主发送
 257   1              
 258   1              SPI_Write_Buf(WRITE_REG + TX_ADDR, TX_ADDRESS, TX_ADR_WIDTH);    // 写本地地址  
 259   1              SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, RX_ADDRESS, RX_ADR_WIDTH); // 写接收端地址
 260   1              SPI_WR_Reg(WRITE_REG + EN_AA, 0);//0x01);                                       //  频道0自动   ACK应答允许     
 261   1              SPI_WR_Reg(WRITE_REG + EN_RXADDR,0);// 0x01);                                   //  允许接收地址只有频道0，如果需要多频道可以参考Page
             -21  
 262   1              SPI_WR_Reg(WRITE_REG + SETUP_RETR, 0);//0x1a);                                  // 设置自动重发时间和次数：500us + 86us, 10 retrans..
             -.
 263   1              SPI_WR_Reg(WRITE_REG + RF_CH, 40);                                                      //   设置信道工作为2.4GHZ，收发必须一致
 264   1              SPI_WR_Reg(WRITE_REG + RX_PW_P0, RX_PLOAD_WIDTH);                               //设置接收数据长度，本次设置为32字节
 265   1              SPI_WR_Reg(WRITE_REG + RF_SETUP, 0x0F);                                                 //设置发射速率为2MHZ，发射功率为最大值0dB
 266   1      
 267   1              SPI_WR_Reg(WRITE_REG + CONFIG, 0x0E);
 268   1          CE = 1;
 269   1      }       
 270          /*******************************************************************************
 271          * 函 数 名         : void nRF24L01_TxPacket
 272          * 函数功能                 : 发送tx_buf中数据
 273          *******************************************************************************/
 274          void nRF24L01_TxPacket(unsigned char * tx_buf)
 275          {
 276   1              CE = 0;                 //StandBy I模式 
 277   1              SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, TX_ADDRESS, TX_ADR_WIDTH); // 装载接收端地址
 278   1              SPI_Write_Buf(WR_TX_PLOAD, tx_buf, TX_PLOAD_WIDTH);                      // 装载数据    
 279   1              //SPI_WR_Reg(WRITE_REG + CONFIG, 0x0e);                  // IRQ收发完成中断响应，16位CRC，主发送
 280   1              CE = 1;          //置高CE，激发数据发送
 281   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    505    ----
   CONSTANT SIZE    =     15    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     10      41
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
