/*********************************************************************************************************
*名称：ChaoShengBo.h
*功能：超声波对应的函数
创建时间：2019/7/5
修改时间：2019/7/5
作者：黄剑桥
*********************************************************************************************************/
#include "ChaoShengBo.h"
unsigned int  time=0;
unsigned int  timer=0;
unsigned char posit=0;
unsigned long S=0;
bit      flag =0;
/**************************************************************************
* 函数名称： Count
* 功能：     计算距离
******************************************************************************/
void Conut()
{
    time=TH0*256+TL0;
    TH0=0;
	TL0=0;
	
	S=(long)(time*0.17);     //算出来单位是CM
	if(S>=4000||flag==1)	  //如果测量范围超出显示“----”
	{
	  flag=0;
	  disbuff[0]=10;	   //“-”
	  disbuff[1]=10;	   //“-”
	  disbuff[2]=10;	   //“-”
	  disbuff[3]=10;
	}
	else
	{
	  disbuff[3]=S%10000/1000;
      disbuff[2]=S%1000/100;
	  disbuff[1]=S%100/10;
	  disbuff[0]=S%10/1;
	}
}

/**************************************************************************
* 函数名称：time0
* 功能：    中断0计算时器溢出，超出测距距离
******************************************************************************/
 void time0() interrupt 1
 {
    flag=1;	//溢出标志

 }

/**************************************************************************
* 函数名称：time1
* 功能：    中断1用来定时扫描数码管和启动超声波模块
******************************************************************************/
void time1() interrupt 3
{
    TH1=0xf8;
	TL1=0x30;
	CsbDisplay();
	timer++;
	if(timer>=400)
	{
	  timer=0;
	  TX=1;				 //启动超声波模块
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_();
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_();
	  TX=0;
	}
	
}

/**************************************************************************
* 函数名称：Initiali
* 功能：    控制中断、定时器、超声波模块
******************************************************************************/
void Initiali()
{
    TMOD=0x11;		   //设T0为方式1，GATE=1；
	TH0=0;
	TL0=0;          
	TH1=0xf8;		   //2MS定时
	TL1=0x30;
	ET0=1;             //允许T0中断
	ET1=1;			   //允许T1中断
	TR1=1;			   //开启定时器
	EA=1;			   //开启总中断

	while(1)
	{
	 while(!RX);		//当RX为零时等待
	 TR0=1;			    //开启计数
	 while(RX);			//当RX为1计数并等待
	 TR0=0;				//关闭计数
     Conut();			//计算
   }
}